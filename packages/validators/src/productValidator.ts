import { z } from "zod";


const ProductSpecificationSchema = z.object({
  id: z.number().optional(),
  productId: z.number(),
  specificationTemplateId: z.number(),
  specificationOptionId: z.number().optional(),
  value: z.string().optional(),
});

const ProductToTemplateSchema = z.object({
  productId: z.number(),
  templateId: z.number(),
});

const ProductCategorySchema = z.object({
  id: z.number(),
  name: z.string(),
  description: z.string().optional(),
});

const fileSchema = typeof window !== 'undefined' ? z.union([z.instanceof(FileList) , z.array(z.instanceof(File))]) : z.array(z.string());
export const ProductSchema = z.object({
  id: z.number().optional(), // ID is optional because it's auto-generated by the database
  name: z.string().min(1, "Należy podać nazwę"),
  categoryId: z.number().nullable().refine(val => val !== null, {
    message: "Należy wybrać kategorię(która nie posiada podkategorii)",
  }),
  description: z.string().optional(),
  price: z.number().min(1, "Price must be a positive number"),
  mainImageIndex: z.number().optional(),
  images: fileSchema.optional(),
  specifications: z.array(ProductSpecificationSchema).optional(),
  templates: z.array(ProductToTemplateSchema).optional(),
  category: z.array(ProductCategorySchema).optional(), // This would be validated in the context where category details are available
});


// Define additional schemas here as necessary for the related models
// Export the schemas
export {
  ProductCategorySchema,
  ProductSpecificationSchema,
  ProductToTemplateSchema,
};

// Infer and export the types
export type Product = z.infer<typeof ProductSchema>;
export type ProductCategory = z.infer<typeof ProductCategorySchema>;
export type ProductSpecification = z.infer<typeof ProductSpecificationSchema>;
export type ProductToTemplate = z.infer<typeof ProductToTemplateSchema>;
